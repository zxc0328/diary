<!DOCTYPE html><!--[if lte IE 8]>
<html lang="en" class="lte-ie8">
<![endif]-->
<!--[if gt IE 8]><!-->
<html lang="en">
<!--<![endif]--><head><meta charset="utf-8"><title>June 7, 2019</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/diary/styles/global.css"><link rel="stylesheet" href="/diary/styles/tomorrow.css"><link rel="stylesheet" href="/diary/styles/diary.css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-63818301-1', 'auto');
ga('send', 'pageview');</script></head><body><header class="header"><div class="index"><a href="/diary/">Index</a></div><h1>June 7, 2019</h1></header><div class="content"><div class="diary"><h2 id="go-heap-go-">Go Heap 的使用以及其他 Go 知识点小记</h2>
<h3 id="heap">Heap</h3>
<p>刷 LeetCode 的时候看一个题需要用到优先队列这个数据结构，这个结构一般用 Heap 实现。Go 标准库里面有 container/heap 这个包。使用的时候需要自己定义一个类型传给 Init 方法，比如一个 IntHeap：</p>
<pre><code><span class="hljs-comment">// This example demonstrates an integer heap built using the heap interface.</span>
package main

import (
    <span class="hljs-string">"container/heap"</span>
    <span class="hljs-string">"fmt"</span>
)

<span class="hljs-comment">// An IntHeap is a min-heap of ints.</span>
<span class="hljs-keyword">type</span> IntHeap []int

func (<span class="hljs-keyword">h</span> IntHeap) Len() int           { <span class="hljs-keyword">return</span> len(<span class="hljs-keyword">h</span>) }
func (<span class="hljs-keyword">h</span> IntHeap) Less(i, j int) bool { <span class="hljs-keyword">return</span> <span class="hljs-keyword">h</span>[i] &lt; <span class="hljs-keyword">h</span>[j] }
func (<span class="hljs-keyword">h</span> IntHeap) Swap(i, j int)      { <span class="hljs-keyword">h</span>[i], <span class="hljs-keyword">h</span>[j] = <span class="hljs-keyword">h</span>[j], <span class="hljs-keyword">h</span>[i] }

func (<span class="hljs-keyword">h</span> *IntHeap) Push(x interface{}) {
    <span class="hljs-comment">// Push and Pop use pointer receivers because they modify the slice's length,</span>
    <span class="hljs-comment">// not just its contents.</span>
<span class="hljs-comment">    *h = append(*h, x.(int))</span>
}

func (<span class="hljs-keyword">h</span> *IntHeap) Pop() interface{} {
    old := *<span class="hljs-literal">h</span>
    <span class="hljs-keyword">n</span> := len(old)
    x := old[<span class="hljs-keyword">n</span>-1]
<span class="hljs-comment">    *h = old[0 : n-1]</span>
    <span class="hljs-keyword">return</span> x
}

<span class="hljs-comment">// This example inserts several ints into an IntHeap, checks the minimum,</span>
<span class="hljs-comment">// and removes them in order of priority.</span>
func main() {
    <span class="hljs-keyword">h</span> := &amp;IntHeap{2, 1, 5}
    heap.Init(<span class="hljs-keyword">h</span>)
    heap.Push(<span class="hljs-keyword">h</span>, 3)
    fmt.Printf(<span class="hljs-string">"minimum: %d\n"</span>, (*<span class="hljs-keyword">h</span>)[0])
    <span class="hljs-keyword">for</span> <span class="hljs-keyword">h</span>.Len() &gt; 0 {
        fmt.Printf(<span class="hljs-string">"%d "</span>, heap.Pop(<span class="hljs-keyword">h</span>))
    }
}
</code></pre><p>需要自己实现一个类型，有 Push/Pop 方法以及 Less/Len/Swap（组合自 sort.Interface）。Heap 的 API 会调用这个类型的方法，来进行操作，这样就可以把 heap 的内部实现和 heap 节点数据类型的定义分离开来。标准库提供的 heap 是一个通用的实现，只要你提供的数据类型符合要求，就可以使用。</p>
<p><a href="https://golang.org/pkg/container/heap/">官方文档</a>中的另一个例子 PriorityQueue 的元素定义就更为复杂一些，但也实现了要求实现的方法，所以也是可以作为 heap 的节点使用的。</p>
<h3 id="pointer-receiver-vs-value-receiver">Pointer receiver vs Value receiver</h3>
<p>一些资料：</p>
<ul>
<li><a href="https://golang.org/doc/faq#methods_on_values_or_pointers">Should I define methods on values or pointers?</a></li>
<li><a href="https://nathanleclaire.com/blog/2014/08/09/dont-get-bitten-by-pointer-vs-non-pointer-method-receivers-in-golang/">Don&#39;t Get Bitten by Pointer vs Non-Pointer Method Receivers in Golang
</a></li>
</ul>
<p>总结一下就是，这两者的差异很小，receiver 基本就是作为一个函数的参数传入的，可以当做一个参数对待。在调用的时候因为编译器会自动做转换，所以不管是指针还是值都可以直接用 a.b 的方式调用。</p>
<blockquote>
<p>A method call x.m() is valid if the method set of (the type of) x contains m and the argument list can be assigned to the parameter list of m. If x is addressable and &amp;x’s method set contains m, x.m() is shorthand for (&amp;x).m()</p>
</blockquote>
<p>两者选用的一些规则：</p>
<blockquote>
<p>First, and most important, does the method need to modify the receiver? If it does, the receiver must be a pointer. (Slices and maps act as references, so their story is a little more subtle, but for instance to change the length of a slice in a method the receiver must still be a pointer.) </p>
</blockquote>
<blockquote>
<p>Second is the consideration of efficiency. If the receiver is large, a big struct for instance, it will be much cheaper to use a pointer receiver.</p>
</blockquote>
<blockquote>
<p>Next is consistency. If some of the methods of the type must have pointer receivers, the rest should too, so the method set is consistent regardless of how the type is used. See the section on method sets for details.</p>
</blockquote>
<h3 id="array-vs-slice">Array vs Slice</h3>
<p>Array 是定宽的，声明语法和 Slice 不同。Array 其实是 Slice 底层的实现，Slice 是在一个底层 Array 之上的滑动窗口。Slice 是可以动态扩容的。</p>
<p>所以简单的说，平时用 Slice 就行。</p>
<blockquote>
<p>最近看一些库的实现，里面如果是想尽量避免 GC，就要尽量手动控制内存。这个时候无脑用 Slice 就不可行。 </p>
</blockquote>
<h3 id="-">其他</h3>
<p>比如 make 和 new 的区别？
Go 的 Type assertion？</p>
<p>关于 Go 里面比较 Subtle 的地方还是很多的，需要更多的看细节，多思考，多学习。</p>
<p>Go 语言规范，Go 官方博客，Go 官网 Faq。都是不错的参考。Go 官网 Faq 里写到 Go 是一门为了工程服务的语言，所以设计的时候就是为了开发者方便，适应现代计算机的多核架构而设计的。具体可以看这篇<a href="https://talks.golang.org/2012/splash.article">分享记录</a>。</p>
</div></div><footer class="footer"><address class="author">Copyright &copy;<a rel="author" href="https://github.com/zxc0328" class="author-name">ccnuzindex</a>-<a href="https://github.com/zxc0328/diary-content.git" class="source-repo">Source</a></address><p>Generated by<a href="https://github.com/joyeecheung/diary" class="site-repo">Joyee Cheung&#39;s diary generator</a></p></footer></body></html>
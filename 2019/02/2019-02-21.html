<!DOCTYPE html><!--[if lte IE 8]>
<html lang="en" class="lte-ie8">
<![endif]-->
<!--[if gt IE 8]><!-->
<html lang="en">
<!--<![endif]--><head><meta charset="utf-8"><title>February 21, 2019</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/diary/styles/global.css"><link rel="stylesheet" href="/diary/styles/tomorrow.css"><link rel="stylesheet" href="/diary/styles/diary.css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-63818301-1', 'auto');
ga('send', 'pageview');</script></head><body><header class="header"><div class="index"><a href="/diary/">Index</a></div><h1>February 21, 2019</h1></header><div class="content"><div class="diary"><h2 id="typescript-handbook-">TypeScript 官方 Handbook 阅读笔记（一）</h2>
<p>打算系统的学一下 TS。TS 最好的材料还是官方的文档，所以打算都精读一下。
TS 的版本迭代很快，对文档大致熟悉之后还可以阅读 TS 的发布日志，看看每个版本都新增了什么特性。
Github 上有个 <a href="https://github.com/basarat/typescript-book">typescript-book</a> 可以供后面深入学习。</p>
<h3 id="interfaces">Interfaces</h3>
<ul>
<li>Readonly 修饰符，只读属性。</li>
<li>属性可以是 Optional 的，在 key 后面加一个 ? 就可以。</li>
<li>Object literal 声明的对象会有 Excess Property Checks，如果这个对象有目标接口不存在的属性，会报错。绕过这个检查的方法是把对象赋值给一个对象。不过大多数情况下 Excess Property Checks 的报错都是 bug。</li>
<li>interface 可以 extends 多个其他接口，这类似一种 mixin。
+</li>
</ul>
<p><strong>用 interface 声明函数：</strong> </p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SearchFunc</span> {</span>
    (<span class="hljs-string">source:</span> string, <span class="hljs-string">subString:</span> string): <span class="hljs-typename">boolean</span>;
}
</code></pre><p>函数类型在检查时检查的是参数的类型，参数的名称可以不一样。然后在写函数的时候，可以不写返回值类型，TS 会自动推导。</p>
<blockquote>
<p>接口可以同时定义函数和其他属性方法。因为在 JS 中 Function 也是一个对象，只不过有一个 call signature。</p>
</blockquote>
<p><strong>Indexable Types</strong></p>
<p>可以使用 <em>index signature</em> 定义类似 Dict 的接口：</p>
<pre><code><span class="hljs-tag">interface</span> <span class="hljs-tag">NumberDictionary</span> {
    <span class="hljs-attr_selector">[index: string]</span>: <span class="hljs-tag">number</span>;
    <span class="hljs-attribute">length</span>: number;    <span class="hljs-comment">// ok, length is a number</span>
    <span class="hljs-attribute">name</span>: string;      <span class="hljs-comment">// error, the type of 'name' is not a subtype of the indexer</span>
}

<span class="hljs-tag">interface</span> <span class="hljs-tag">StringArray</span> {
    <span class="hljs-attr_selector">[index: number]</span>: <span class="hljs-tag">string</span>;
}
</code></pre><p>index 可以是 number 或者 string。如果两者同时出现，number 类型的 index 的 value 类型必须和 string 类型 index 的 value 类型一致，或是子类型。因为 JS 中 number 类型的 index 会被自动转换为 string。</p>
<p><strong>Class Types</strong></p>
<p>Class 也可以 implement 一个接口。接口定义了 Class 的属性和方法。需要注意的接口定义的都是 Class 的<strong>公有</strong>属性和方法。</p>
<pre><code><span class="hljs-interface"><span class="hljs-keyword">interface</span> ClockInterface </span>{
    currentTime: <span class="hljs-built_in">Date</span>;
    setTime(d: <span class="hljs-built_in">Date</span>);
}

<span class="hljs-keyword">class</span> Clock <span class="hljs-keyword">implements</span> ClockInterface {
    currentTime: <span class="hljs-built_in">Date</span>;
    setTime(d: <span class="hljs-built_in">Date</span>) {
        <span class="hljs-keyword">this</span>.currentTime = d;
    }
    <span class="hljs-constructor"><span class="hljs-keyword">constructor</span>(h: number, m: number) </span>{ }
}
</code></pre><p><strong>Interfaces Extending Classes</strong></p>
<p>interface 也可以 extend Class。接口会继承 Class 的公有、私有属性和方法，但不包括这些方法的实现。
如果一个 Class 要 implement 一个继承自 Class 的 interface，这个 Class 必须是接口继承的 Class 的 SubClass。</p>
<h3 id="classes">Classes</h3>
<ul>
<li>public，private（私有，Class 内部可以访问），protected（子类可以访问）三种访问控制符</li>
<li>属性和方法默认都是 public 的。</li>
<li>继承的时候如果父类有构造函数，子类必须也有构造函数，然后调 super。</li>
<li>Parameter properties：在构造函数参数里声明属性（可以带访问控制修饰符）。</li>
<li>支持 getter 和 setter。</li>
<li>静态属性定义在 Class 的定义（构造函数）上。</li>
</ul>
<p><strong>Abstract Classes</strong></p>
<p>抽象类里面定义的方法可以有实现，如果没有实现，只是定义，那需要在方法前面加 abstract 关键字。</p>
<h3 id="functions">Functions</h3>
<ul>
<li>函数定义的基本语法： (x: number, y: number) =&gt; number</li>
<li>函数可以在参数后面加 ? 表示这个参数的 optional 的</li>
</ul>
<p><strong><code>this</code> parameters</strong></p>
<p><code>this</code> 需要作为第一个参数声明，在调用的时候这个参数是省略的。</p>
<pre><code>function f(<span class="hljs-attribute">this</span>: void) {
    <span class="hljs-regexp">//</span> make sure `<span class="javascript"><span class="hljs-keyword">this</span></span>` <span class="hljs-keyword">is</span> unusable <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span> standalone function
}
</code></pre><p><code>this: void</code> 表示不适用 <code>this</code></p>
<p><code>this</code> 也可以传入一个类型，这样就显示标注了 <code>this</code> 的类型</p>
<pre><code><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> {
    info: <span class="hljs-keyword">string</span>;
    onClickBad(<span class="hljs-keyword">this</span>: Handler, e: Event) {
        <span class="hljs-comment">// oops, used this here. using this callback would crash at runtime</span>
        <span class="hljs-keyword">this</span>.info = e.message;
    }
}
</code></pre><p>在函数中加入 <code>this</code> 类型的标注可以避免因为 <code>this</code> 指向而产生的错误。因为当你传入函数时，对方的函数签名的 <code>this</code> 如果和你传入函数的不一致，就会报错。</p>
<p><strong>Overloads</strong></p>
<p>TS 支持函数重载，基于的语法是这样的：</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pickCard</span><span class="hljs-params">(x: {suit: string; card: number; }[])</span><span class="hljs-type">: number</span></span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pickCard</span><span class="hljs-params">(x: number)</span><span class="hljs-type">: {suit</span><span class="hljs-type">: string</span></span>; card: number; };
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pickCard</span><span class="hljs-params">(x)</span><span class="hljs-type">: any</span> </span>{
    <span class="hljs-comment">// Check to see if we're working with an object/array</span>
    <span class="hljs-comment">// if so, they gave us the deck and we'll pick the card</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x == <span class="hljs-string">"object"</span>) {
        let pickedCard = Math.floor(Math.random() * x.length);
        <span class="hljs-keyword">return</span> pickedCard;
    }
    <span class="hljs-comment">// Otherwise just let them pick the card</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x == <span class="hljs-string">"number"</span>) {
        let pickedSuit = Math.floor(x / <span class="hljs-number">13</span>);
        <span class="hljs-keyword">return</span> { suit: suits[pickedSuit], card: x % <span class="hljs-number">13</span> };
    }
}

</code></pre><h3 id="generics">Generics</h3>
<p>TS 支持泛型，这个特性是我之前所不熟悉的。C++ 和 Java 都支持泛型，所以其实这是一个非常常用的语言特性。</p>
<pre><code><span class="hljs-keyword">function</span> identity&lt;<span class="hljs-literal">T</span>&gt;(arg: <span class="hljs-literal">T</span>): <span class="hljs-literal">T</span> {
    <span class="hljs-keyword">return</span> arg;
}
</code></pre><p>这里的 T 叫做 Type Variable。也就是一个表示类型的变量。是一个特殊的变量。</p>
<p>接口，类的泛型声明：</p>
<pre><code>interface GenericIdentityFn&lt;<span class="hljs-literal">T</span>&gt; {
    (arg: <span class="hljs-literal">T</span>): <span class="hljs-literal">T</span>;
}

class GenericNumber&lt;<span class="hljs-literal">T</span>&gt; {
    zeroValue: <span class="hljs-literal">T</span>;
    add: (x: <span class="hljs-literal">T</span>, y: <span class="hljs-literal">T</span>) =&gt; <span class="hljs-literal">T</span>;
}
</code></pre><p>可以看到接口和类内部都可以访问到这个 T 变量。</p>
<p>泛型的类型可以 extens 一个接口，这样就对泛型的类型加上了一些自定义的限制：</p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Lengthwise</span> </span>{
    length: number;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loggingIdentity</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">Lengthwise</span>&gt;<span class="hljs-params">(arg: T)</span>: <span class="hljs-title">T</span> </span>{
    console.log(arg.length);  <span class="hljs-comment">// Now we know it has a .length property, so no more error</span>
    <span class="hljs-keyword">return</span> arg;
}
</code></pre><p>这就是一个经典的例子，K 只能是 T 的某个 key：</p>
<pre><code><span class="hljs-keyword">function</span> getProperty&lt;<span class="hljs-literal">T</span>, K extends keyof <span class="hljs-literal">T</span>&gt;(obj: <span class="hljs-literal">T</span>, key: K) {
    <span class="hljs-keyword">return</span> obj[key];
}
</code></pre></div></div><footer class="footer"><address class="author">Copyright &copy;<a rel="author" href="https://github.com/zxc0328" class="author-name">ccnuzindex</a>-<a href="https://github.com/zxc0328/diary-content.git" class="source-repo">Source</a></address><p>Generated by<a href="https://github.com/joyeecheung/diary" class="site-repo">Joyee Cheung&#39;s diary generator</a></p></footer></body></html>
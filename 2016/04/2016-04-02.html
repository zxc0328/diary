<!DOCTYPE html><!--[if lte IE 8]>
<html lang="en" class="lte-ie8">
<![endif]-->
<!--[if gt IE 8]><!-->
<html lang="en">
<!--<![endif]--><head><meta charset="utf-8"><title>April 2, 2016</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/diary/styles/global.css"><link rel="stylesheet" href="/diary/styles/tomorrow.css"><link rel="stylesheet" href="/diary/styles/diary.css"></head><body><header class="header"><div class="index"><a href="/diary/">Index</a></div><h1>April 2, 2016</h1></header><div class="content"><div class="diary"><h2 id="-">背包问题与动态规划</h2>
<h3 id="-">背包问题</h3>
<p>这个题目是2014腾讯笔试题中的编程题，属于经典的背包问题。</p>
<blockquote>
<p>“背包题目”的基本描述是：有一个背包，能盛放的物品总重量为S,设有N件物品，其重量分别为w1，w2，…，wn，希望从N件物品中选择若干物品，所选物品的重量之和恰能放进该背包，即所选物品的重量之和即是S。递归和非递归解法都能求得“背包题目”的一组解，试写出“背包题目”的非递归解法</p>
</blockquote>
<h3 id="-">递推式分析</h3>
<p>与算法书上求所放物品价值最大的背包问题不同，这个背包问题只要我们求重量之和是否是<code>S</code>。因此我们可以把结果抽象为可以和不可以两种情况。也就是说结果矩阵<code>f[i][j]</code>中存储的是第一件到第<code>i</code>件物品可不可以放入容量为<code>j</code>的背包中。</p>
<p>在放入第i件物品时，我们判断第<code>i</code>个物品的重量是否大于<code>j</code>，如果大于则无法放入，那么
<code>f[i][j] = f[i-1][j];</code>，即和<code>i-1</code>时的情况没有区别。</p>
<p>如果第<code>i</code>个物品的重量小于于<code>j</code>，那么我们同时查看放入<code>i</code>和不放入<code>i</code>两种情况下的可行性，取可行的方案。如果放入，则它的可行性就变为了前<code>i-1</code>件物品是否能恰好装入<code>j-vec[i]</code>容量的背包中可行性了；选择不装，则它的可行性与<code>i-1</code>时的情况没有区别。</p>
<p>所以最后的代码是这样的：</p>
<pre><code><span class="hljs-comment">// credit http://www.nowcoder.com/test/question/done?tid=2909898&amp;qid=897#summary  </span>
<span class="hljs-comment">// by Zack6514</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packageInteration</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec, <span class="hljs-keyword">int</span> S)</span></span>{
    <span class="hljs-keyword">int</span> n = vec.size();
    <span class="hljs-keyword">int</span> **f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>*[n+<span class="hljs-number">1</span>];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n+<span class="hljs-number">1</span>; i++){
        f[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[S+<span class="hljs-number">1</span>];
        <span class="hljs-built_in">memset</span>(f[i], <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(f[i])*(S+<span class="hljs-number">1</span>));
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n+<span class="hljs-number">1</span>; i++)
        f[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 初始化</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n+<span class="hljs-number">1</span>; i++){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; S+<span class="hljs-number">1</span>; j++){
            <span class="hljs-keyword">if</span>(j &gt;= vec[i-<span class="hljs-number">1</span>])
                f[i][j] = (f[i-<span class="hljs-number">1</span>][j] || f[i-<span class="hljs-number">1</span>][j-vec[i-<span class="hljs-number">1</span>]]);
            <span class="hljs-keyword">else</span>
                 f[i][j] = f[i-<span class="hljs-number">1</span>][j];
        }   
    }
    <span class="hljs-comment">// 回溯求结果</span>
    <span class="hljs-keyword">int</span> j = S;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n; i &gt; <span class="hljs-number">0</span>; i--){
        <span class="hljs-keyword">if</span>(j &gt;= vec[i-<span class="hljs-number">1</span>]){
            <span class="hljs-keyword">if</span>(f[i][j-vec[i-<span class="hljs-number">1</span>]] == <span class="hljs-number">1</span>){   <span class="hljs-comment">// 为1 表示可行</span>
                res.push_back(i);
                j = j - vec[i-<span class="hljs-number">1</span>];
            }
        }
    }
}
</code></pre><h3 id="-">动态规划</h3>
<p>动态规划在我看来就是一种典型的“空间换时间”的做法。利用了递推式，存储下之前的计算结果，从而在有限时间内解出答案。</p>
<h3 id="links">Links</h3>
<ul>
<li><a href="http://www.nowcoder.com/test/question/done?tid=2909898&amp;qid=897#summary">背包题目</a></li>
<li><a href="http://blog.chinaunix.net/uid-26548237-id-3374211.html">最长公共子序列（LCS）问题</a></li>
<li>《Introduction to algorithms 3rd edition》15.4 Longest common subsequence</li>
</ul>
</div></div><footer class="footer"><address class="author">Copyright &copy;<a rel="author" href="https://github.com/zindex" class="author-name">Zindex</a>-<a href="https://github.com/zxc0328/diary-content" class="source-repo">Source</a></address><p>Generated by<a href="https://github.com/joyeecheung/diary" class="site-repo">Joyee Cheung&#39;s diary generator</a></p></footer></body></html>
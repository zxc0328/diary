<!DOCTYPE html><!--[if lte IE 8]>
<html lang="en" class="lte-ie8">
<![endif]-->
<!--[if gt IE 8]><!-->
<html lang="en">
<!--<![endif]--><head><meta charset="utf-8"><title>September 21, 2016</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/diary/styles/global.css"><link rel="stylesheet" href="/diary/styles/tomorrow.css"><link rel="stylesheet" href="/diary/styles/diary.css"></head><body><header class="header"><div class="index"><a href="/diary/">Index</a></div><h1>September 21, 2016</h1></header><div class="content"><div class="diary"><h2 id="-">长列表渲染</h2>
<p>之前在面试的时候被问到一个问题，就是如何在移动端渲染一个长列表。那个时候还不明所以。知道用了iOS的tableView之后，知道了有一招，回收利用tableCell。</p>
<p>在DOM base的web页面里，所对应的其实就是控制DOM节点的数量，只让viewport中会出现的DOM节点以及附近的节点出现，而在viewport之外的节点压根就不用在页面上存在。我们可以打开看一下Clusterize.js的<a href="https://clusterize.js.org">主页</a>看一下有5000个节点列表的页面，滚动起来是有多卡。</p>
<p>比如一个Vue组件，data是一个数组，用这个数组来渲染一个组件list。比如我们规定最多同时只能存在20个list，这些list我们按5个分为一组。那么当滑动到最后一组（16-20个）的时候，我们就要加载21-25这组内容。此时我们会移除1-5这最开始的一组组件。</p>
<p>有一个问题，移除DOM节点之后整个页面会往上移动。这样显然是不行的。我们对DOM的移除不能被用户察觉。</p>
<p>解决办法就是在list的上方放一个DOM节点。初始高度为0.当移除一组节点时，这个占位节点的高度就相应的增加，来占之前节点的位置。如果操作得当，增加高度和删除节点在一次浏览器的渲染周期，也就是16ms内完成，那用户是无法察觉的。而且因为高度占位，滚动条也是正确的。</p>
<p>当然往回滚动时就变成了减少占位节点的高度了。</p>
<p>这个理论应该是没有问题的。大家可以实践一下试试。</p>
<h3 id="links">Links</h3>
<ul>
<li><a href="https://clusterize.js.org">Clusterize.js</a></li>
<li><a href="https://github.com/jwarning/react-scrollable-list">react-scrollable-list</a></li>
</ul>
</div></div><footer class="footer"><address class="author">Copyright &copy;<a rel="author" href="https://github.com/zindex" class="author-name">Zindex</a>-<a href="https://github.com/zxc0328/diary-content" class="source-repo">Source</a></address><p>Generated by<a href="https://github.com/joyeecheung/diary" class="site-repo">Joyee Cheung&#39;s diary generator</a></p></footer></body></html>
<!DOCTYPE html><!--[if lte IE 8]>
<html lang="en" class="lte-ie8">
<![endif]-->
<!--[if gt IE 8]><!-->
<html lang="en">
<!--<![endif]--><head><meta charset="utf-8"><title>December 6, 2016</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/diary/styles/global.css"><link rel="stylesheet" href="/diary/styles/tomorrow.css"><link rel="stylesheet" href="/diary/styles/diary.css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-63818301-1', 'auto');
ga('send', 'pageview');</script></head><body><header class="header"><div class="index"><a href="/diary/">Index</a></div><h1>December 6, 2016</h1></header><div class="content"><div class="diary"><h2 id="vue-">Vue源码结构整理</h2>
<h3 id="overview">Overview</h3>
<p><img src="https://occc3ev3l.qnssl.com/Vue%20source%20overview.png" alt="overview"></p>
<h3 id="-">源码的分层</h3>
<p>首先Vue的源码的真正入口应该是<code>platform</code>那个文件夹里面。Vue中的模块，我简单的分为实例方法、生命周期相关的（Instance/Lifecircle）。和响应式原理相关的（Watcher/Dep/Observer）。以及Virtual DOM部分。当然还有一些Utility的，比如事件，helper函数，DOM操作等。</p>
<p>其中可以单独拿出来的就是Compiler，因为这部分不属于runtime，这部分的作用是编译模板，转换为一个包含了AST以及静态子树的<code>render</code>函数。</p>
<p>所谓静态子树，应该指的就是那些没有包含数据绑定的HTML节点树，对于这些树，我们可以直接抽取出来。这个应该和React里的无状态箭头函数组件类似？但似乎又不是。需要进一步的了解。</p>
<h3 id="-">指令</h3>
<p>首先，Vue自带的那些指令都放在<code>platform/web</code>下面，而不是在<code>src</code>下面。自定义指令的代码则是在<code>src/core/vdom/modules/directive.js</code>下。</p>
<h3 id="patch-">Patch函数</h3>
<p>对于DOM渲染时需要做的一些操作，Vue对<a href="https://github.com/snabbdom/snabbdom">这个vdom库</a>做了一些修改，大致就是在<code>runtime</code>的一开始注册模块（主要是<code>platforms/web/runtime/modules</code>下）每个模块都有<code>create</code>，<code>update</code>和<code>destory</code>的接口函数，在patch的时候，会在patch的相应阶段运行这些接口。</p>
<p>比如自定义指令里的那些钩子函数就是在<code>src/core/vdom/modules/directive.js</code>的<code>create</code>，<code>update</code>等方法里面触发的。</p>
<h3 id="virtual-dom">Virtual DOM</h3>
<p>Virtual DOM加入了之后，其实Vue的渲染流程就边的比较清晰了。之前注册在Watcher上的callback，里面的逻辑就是update vdom树，其实就是运行patch函数。对于patch时需要操作的DOM逻辑，已经按之前小节说的挂载在patch的各个周期了。对于一遍的数据上的改变需要映射到，普通的vdom diff就足够了。所以vdom实际是一层抽象。Reactive那套系统，其实在Vue1.0和2.0之间的差别不是很大。关键就是render函数以及对应的vdom的引入，完成了这层抽象。</p>
<p>如果想要查看组件的vdom树，可以运行实例的<code>_render</code>方法。</p>
<h3 id="what-s-next-">What&#39;s next?</h3>
<p>首先，生命周期和Reactive这套，是资料比较多也比较容易理解的。可以先实现一个子系统的demo。vdom，首先需要看原先vue借鉴的vdom系统，然后再研究vdom和Vue里的一些指令是如何整合的。Compiler这个，其实不看也没有太大的关系。Compiler主要就是一个HTML parser。因为Vue这次的平台不止是Web，因此需要一个单独的parser，不能再借助浏览器的API了。</p>
<h3 id="links">Links</h3>
<ul>
<li><a href="https://segmentfault.com/a/1190000007484936">Vue 2.0源码学习</a></li>
</ul>
</div></div><footer class="footer"><address class="author">Copyright &copy;<a rel="author" href="https://github.com/zxc0328" class="author-name">ccnuzindex</a>-<a href="https://github.com/zxc0328/diary-content.git" class="source-repo">Source</a></address><p>Generated by<a href="https://github.com/joyeecheung/diary" class="site-repo">Joyee Cheung&#39;s diary generator</a></p></footer></body></html>
<!DOCTYPE html><!--[if lte IE 8]>
<html lang="en" class="lte-ie8">
<![endif]-->
<!--[if gt IE 8]><!-->
<html lang="en">
<!--<![endif]--><head><meta charset="utf-8"><title>March 31, 2016</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/diary/styles/global.css"><link rel="stylesheet" href="/diary/styles/tomorrow.css"><link rel="stylesheet" href="/diary/styles/diary.css"></head><body><header class="header"><div class="index"><a href="/diary/">Index</a></div><h1>March 31, 2016</h1></header><div class="content"><div class="diary"><h2 id="vue-watch-">Vue中watch机制实现解读</h2>
<p>这是阅读<a href="https://segmentfault.com/a/1190000004384515">vue源码分析之如何实现observer和watcher</a>文后的一些思考。</p>
<h3 id="-object-defineproperty-"><code>Object.defineProperty</code>与双向数据绑定</h3>
<p>实现MVVM框架中的双向数据绑定的办法有很多，其中Angularjs的实现机制是dirty data checking。而我目前在关注的是Avalonjs和Vuejs中用来实现数据绑定的<code>Object.defineProperty</code>。</p>
<p>大致的原理就是<code>Object.defineProperty</code>可以来设置一个属性的getter和setter。然后我们就可以在这两个回调上面做文章。利用类似Pub/Sub的方式通知View或者Model更新。</p>
<h3 id="mediator">Mediator</h3>
<p>Vue的watch机制就是，可以在修改Model值的时候触发一个回调。实现了一个数据的单向绑定。</p>
<p>Vue中的Model只是plain JavaScript Object。关键在于这个对象的所有属性都被加上了getter和setter。</p>
<p>那Model被更改之后如何和其他组件通信呢？这里我们的设计模式其实不是原始的Pub/Sub，而是一种Mediator pattern。</p>
<p>这篇文章代码中的Observer，我认为应该叫MakeObservable比较好。这个Observer的作用主要是用来遍历属性并添加相应的getter和setter。以及一些初始化工作。</p>
<p>Watcher对象在需要绑定数据时初始化，之后这个Watcher对象被放入需要观察的属性的deps列表里。当对象的这个属性被修改时，setter就会通知deps中的Watcher，然后Watcher负责调用回调。所以Watcher在这个系统中是一个类似于Mediator的角色。</p>
<h3 id="_proxy">_proxy</h3>
<p>有段代码我之前不是很清楚：</p>
<pre><code><span class="hljs-constructor"><span class="hljs-keyword">constructor</span> (options=</span>{}) {
    <span class="hljs-comment">//这里简化了。。其实要merge</span>
    <span class="hljs-keyword">this</span>.$options=options
    <span class="hljs-comment">//这里简化了。。其实要区分的</span>
    <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">this</span>._data=<span class="hljs-keyword">this</span>.$options.data
    <span class="hljs-built_in">Object</span>.keys(data).forEach(key=&gt;<span class="hljs-keyword">this</span>._proxy(key))
    observe(data,<span class="hljs-keyword">this</span>)
  }
</code></pre><p>后来发现，这个Model中的原始数据在<code>_data</code>这个属性中，比如<code>Model._data.a</code>而我们又是直接访问<code>Model.a</code>。但是Model上压根没这个属性啊~</p>
<p>所以我们就调用了<code>_proxy</code>方法：</p>
<pre><code>
  _proxy(key) {

    <span class="hljs-keyword">var</span> <span class="hljs-keyword">self</span> = this
    Object.defineProperty(<span class="hljs-keyword">self</span>, key, {
      configurable: <span class="hljs-keyword">true</span>,
      enumerable: <span class="hljs-keyword">true</span>,
      get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxyGetter</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>._data[key]
      },
      set: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxySetter</span> <span class="hljs-params">(val)</span> </span>{
        <span class="hljs-keyword">self</span>._data[key] = val
      }
    })
  }
</code></pre><p>将<code>_data</code>中的key都添加到Model上，并且设置了代理的getter/setter，将对应的属性读写映射到<code>self._data</code>。这样就实现了<code>Model.a === Model._data.a</code>。</p>
</div></div><footer class="footer"><address class="author">Copyright &copy;<a rel="author" href="https://github.com/zindex" class="author-name">Zindex</a>-<a href="https://github.com/zxc0328/diary-content" class="source-repo">Source</a></address><p>Generated by<a href="https://github.com/joyeecheung/diary" class="site-repo">Joyee Cheung&#39;s diary generator</a></p></footer></body></html>
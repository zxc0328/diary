<!DOCTYPE html><!--[if lte IE 8]>
<html lang="en" class="lte-ie8">
<![endif]-->
<!--[if gt IE 8]><!-->
<html lang="en">
<!--<![endif]--><head><meta charset="utf-8"><title>November 11, 2017</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/diary/styles/global.css"><link rel="stylesheet" href="/diary/styles/tomorrow.css"><link rel="stylesheet" href="/diary/styles/diary.css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-63818301-1', 'auto');
ga('send', 'pageview');</script></head><body><header class="header"><div class="index"><a href="/diary/">Index</a></div><h1>November 11, 2017</h1></header><div class="content"><div class="diary"><h2 id="liso-">Liso源码阅读笔记</h2>
<p>本文介绍了CMU 15-441的课程项目<a href="">Liso</a>的一个实现。主要介绍了请求流程、Client状态机模型、Dynamic Buffer数据结构等等。SSL相关的部分没有涉及。</p>
<h3 id="-">实现</h3>
<p>我看的是这位同学的<a href="https://github.com/zhuansunxt/Liso">实现</a>。</p>
<h3 id="-http-">一个HTTP静态文件请求的流程</h3>
<p>首先我们拿一个简单的静态文件请求来梳理一下Liso的流程。在<code>liso.c</code>的<code>main</code>函数中，有这个服务器的主循环，这个循环每次做的事情就是用<code>select</code>来查询I/O事件。<code>select</code>之后，我们首先做的是查看<code>listenfd</code>是不是有read事件，如果有就<code>accept</code>这个连接。然后把连接加入到连接池里。一个连接的初始状态是<code>READY_FOR_READ</code>。</p>
<p><code>listenfd</code>是连接池中的第一个item，也是一直存在于连接池中的一个描述符。</p>
<p>在循环的最后，我们会调用<code>handle_clients</code>对连接池中可读和可写的描述符依次进行处理。具体的方式就是遍历连接池，如果一个连接是可读的，并且状态是<code>READY_FOR_READ</code>，我们就读取这个连接中的数据。</p>
<p>每次从每个连接读取的数据是固定的长度，比如4KB。这是为了控制I/O的粒度，不让server在一个连接上花太多时间，使得新的连接请求被阻塞。</p>
<p>我们把收到的数据，放到<code>client_buffer</code>里面。然后看一下HTTP的Header是不是已经读取完全了（调用<code>handle_recv_header</code>判断读取到的数据中是否有<code>&quot;\r\n\r\n&quot;</code>）。如果HTTP的header还没有读取完全，那就继续留在<code>READY_FOR_READ</code>状态，等待下一次循环。</p>
<p>如果Header已经读取完全了，我们就调用<code>handle_http_request</code>处理请求，在处理请求时，我们把要返回的数据写在<code>client_buffer</code>里，然后调整这个client的state到<code>READY_FOR_WRITE</code>。</p>
<p>在<code>handle_clients</code>的循环中，如果我们发现一个client的状态是<code>READY_FOR_WRITE</code>，我们就会把<code>client_buffer</code>里相关的数据写到客户端，然后根据这个连接的<code>Connection</code>Header选择关闭或者保留这个连接。</p>
<p>这就是一个简单的HTTP静态文件请求的流程。</p>
<h3 id="-">连接池的数据结构</h3>
<pre><code>typedef struct {
  /<span class="hljs-keyword">*</span> Client pool global data <span class="hljs-keyword">*</span>/
  fd_set master;              /<span class="hljs-keyword">*</span> all descritors <span class="hljs-keyword">*</span>/
  fd_set read_fds;            /<span class="hljs-keyword">*</span> all ready-to-read descriptors <span class="hljs-keyword">*</span>/
  fd_set write_fds;           /<span class="hljs-keyword">*</span> all ready-to_write descriptors <span class="hljs-keyword">*</span>/
  int maxfd;                  /<span class="hljs-keyword">*</span> maximum value of all descriptors <span class="hljs-keyword">*</span>/
  int nready;                 /<span class="hljs-keyword">*</span> number of ready descriptors <span class="hljs-keyword">*</span>/
  int maxi;                   /<span class="hljs-keyword">*</span> maximum index of available slot <span class="hljs-keyword">*</span>/

  /<span class="hljs-keyword">*</span> Client specific data <span class="hljs-keyword">*</span>/
  int client_fd[FD_SETSIZE];  /<span class="hljs-keyword">*</span> client slots <span class="hljs-keyword">*</span>/
  dynamic_buffer <span class="hljs-keyword">*</span> client_buffer[FD_SETSIZE];   /<span class="hljs-keyword">*</span> client's dynamic-size buffer <span class="hljs-keyword">*</span>/
  dynamic_buffer <span class="hljs-keyword">*</span> back_up_buffer[FD_SETSIZE];  /<span class="hljs-keyword">*</span> store historical pending request <span class="hljs-keyword">*</span>/
  size_t received_header[FD_SETSIZE];           /<span class="hljs-keyword">*</span> store header ending's offset <span class="hljs-keyword">*</span>/
  char should_be_close[FD_SETSIZE];             /<span class="hljs-keyword">*</span> whether client should be closed when checked <span class="hljs-keyword">*</span>/
  client_state state[FD_SETSIZE];               /<span class="hljs-keyword">*</span> client's state <span class="hljs-keyword">*</span>/
  char <span class="hljs-keyword">*</span>remote_addr[FD_SETSIZE];                /<span class="hljs-keyword">*</span> client's remote address <span class="hljs-keyword">*</span>/

  /<span class="hljs-keyword">*</span> SSL related <span class="hljs-keyword">*</span>/
  client_type type[FD_SETSIZE];                 /<span class="hljs-keyword">*</span> client's type: HTTP or HTTPS <span class="hljs-keyword">*</span>/
  SSL <span class="hljs-keyword">*</span> context[FD_SETSIZE];                    /<span class="hljs-keyword">*</span> set if client's type is HTTPS <span class="hljs-keyword">*</span>/

  /<span class="hljs-keyword">*</span> CGI related <span class="hljs-keyword">*</span>/
  int cgi_client[FD_SETSIZE];
} client_pool;
</code></pre><p>每个socket连接在建立之后都会被放到<code>client_pool</code>里面。连接池在概念上就是一个大的数组。实现的时候，我们把每个连接相关的属性各自设置为一个相同大小的数组。每个item的属性就是属性数组中相应index的值。比如我们可以通过<code>client_pool-&gt;client_fd[i]</code>拿到第i个请求的fd。其他属性也是类似的。</p>
<p><code>FD_SETSIZE</code>这个常量是这个server并发连接的最大值，这个常量的大小一般是1024。这个值是操作系统设置的。这个连接池里除了各个连接相关信息的数组之外，还有几个<code>fd_set</code>类型的全局属性，其中<code>master</code>里保存了整个连接池的描述符。这也就是我们<code>select</code>循环时监听的目标。需要注意的是CGI连接在建立之后，也会被放到这个连接池中（<code>client_fd</code>指向发起CGI请求的客户端，<code>cgi_client</code>指向CGI连接，这个连接在CGI处理完后会被我们从连接池中清除）。这样我们就可以利用<code>select</code>对CGI请求进行事件驱动的异步处理。</p>
<h3 id="client-">client的状态机模型</h3>
<p>我们知道有限状态机由一组状态和一组转移组成，在Liso里，一个client的状态有以下几种：</p>
<pre><code>typedef <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">client_state</span> {</span>
    <span class="hljs-constant">INVALID</span>,
    <span class="hljs-constant">READY_FOR_READ</span>,
    <span class="hljs-constant">READY_FOR_WRITE</span>,
    <span class="hljs-constant">WAITING_FOR_CGI</span>,
    <span class="hljs-constant">CGI_FOR_READ</span>,
    <span class="hljs-constant">CGI_FOR_WRITE</span>
} client_state;
</code></pre><p>在讲具体的状态模型之前，我们要把连接池中的连接分为两种，一种是客户端的连接描述符，一种是CGI连接。这两种连接的在连接池中的数据结构是相同的。</p>
<p>在处理HTTP请求时，如果一个请求是CGI请求，我们就会fork一个进程，获取CGI的文件描述符，然后调用<code>add_cgi_fd_to_pool</code>函数将这个描述符加入到连接池中。加入操作的核心代码是：</p>
<pre><code>/* <span class="hljs-type">Update</span> client <span class="hljs-typedef"><span class="hljs-keyword">data</span> */</span>
<span class="hljs-title">p</span>-&gt;client_fd[i] = cgi_fd;
<span class="hljs-title">p</span>-&gt;state[i] = state;

/* <span class="hljs-type">CGI</span> */
<span class="hljs-title">p</span>-&gt;cgi_client[i] = clientfd;
</code></pre><p>所以这个连接和普通的连接一样，都有<code>client_fd</code>属性，不同的是这个连接有一个<code>cgi_client</code>属性，指向CGI连接的文件描述符。所以在处理CGI请求的时候，一个连接在连接池中有客户端连接和CGI连接两个item。CGI连接的状态仅仅只是在<code>CGI_FOR_READ</code>和<code>CGI_FOR_WRITE</code>之间转换。在CGI连接可读，并被写到客户端之后，我们会从连接池中清除这个CGI的item。所以客户端连接和CGI连接的状态机模型应该分开讲述。</p>
<h4 id="-">客户端连接状态机模型</h4>
<p><img src="https://wx1.sinaimg.cn/mw1024/64c45edcgy1flgj3kbvxjj20vu0g0adc.jpg" alt="static fsm"></p>
<p>客户端连接，如果是CGI连接，会比静态资源请求多一个<code>WAITING_FOR_CGI</code>的状态。这里我们需要注意的是，我们在读取一个连接的数据时，如果是一个POST请求，一般会分很多次。如果读取之后数据不够，这个连接的状态就会停留在<code>READY_FOR_READ</code>，等待下一次<code>select</code>循环。直到读取到足够的数据（根据Header里的<code>content-length</code>）之后，才把这个请求的状态转移到<code>READY_FOR_WRITE</code>。</p>
<h4 id="cgi-">CGI连接状态机模型</h4>
<p><img src="https://wx2.sinaimg.cn/mw1024/64c45edcgy1flgj3k7yopj20uc0dwacw.jpg" alt="cgi fsm"></p>
<h3 id="-">长连接</h3>
<p>我们知道HTTP的Header中有一个Connection字段。如果这个字段的值为close，在<code>READY_FOR_WRITE</code>状态时，如果我们写完了当前请求所请求的数据，我们就关闭连接。如果这个字段的值为<code>keep-alive</code>，连接会经过<code>Persist</code>转移，重新进入<code>READY_FOR_WRITE</code>状态。</p>
<p>在写完数据之后依然保持<code>READY_FOR_WRITE</code>状态，不关闭连接，这就是我们常说的HTTP<code>keep-alive</code>长连接。在这种情况下，server假定的是在未来的某个时间节点，这个客户端上还有数据可以读取，所以我们暂时不关闭连接。</p>
<p>举例说一下HTTP长连接的用途：如果一个域下有多个资源需要请求，浏览器会复用同一个TCP连接。也就是说服务器可以在一个TCP连接上进行多次HTTP请求。这样有利于减少网络延迟和服务器的并发压力。</p>
<h3 id="dynamic-buffer-">Dynamic Buffer数据结构</h3>
<p>Dynamic Buffer数据结构是对普通buffer的封装。为了应对HTTP请求中长度不一定的二进制数据，我们需要一个封装良好的buffer结构，让我们方向的使用，不用担心内存管理问题。</p>
<pre><code><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> dynamic_buffer{
  <span class="hljs-keyword">char</span> *buffer;
  <span class="hljs-keyword">size_t</span> offset;
  <span class="hljs-keyword">size_t</span> capacity;
  <span class="hljs-keyword">size_t</span> send_offset;
} dynamic_buffer;
</code></pre><p><code>dynamic_buffer</code>类型用struct封装了一个新的类型，<code>buffer</code>指向实际存储数据的buffer。另外还有<code>offset</code>、<code>capacity</code>和<code>send_offset</code>这些属性来辅助内存管理。<code>offset</code>让我们掌握目前buffer的实际容量是多少。<code>capacity</code>让我们可以掌握buffer占用的内存大小，方便动态的扩容。作者说这个设计是模仿的C++ vector STL。</p>
<h3 id="cgi-">CGI相关</h3>
<p>Liso中用来描述一个CGI执行进程的数据结构是这样的：</p>
<pre><code><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-built_in">CGI_executor</span> {
  <span class="hljs-keyword">int</span> clientfd;
  <span class="hljs-keyword">int</span> stdin_pipe[<span class="hljs-number">2</span>];    <span class="hljs-comment">/* { write data --&gt; stdin_pipe[1] } -&gt; { stdin_pipe[0] --&gt; stdin } */</span>
  <span class="hljs-keyword">int</span> stdout_pipe[<span class="hljs-number">2</span>];   <span class="hljs-comment">/* { read data &lt;--  stdout_pipe[0] } &lt;-- {stdout_pipe[1] &lt;-- stdout } */</span>
  dynamic_buffer* cgi_buffer;
  <span class="hljs-built_in">CGI_param</span>* cgi_parameter;
} <span class="hljs-built_in">CGI_executor</span>;
</code></pre><p>里面主要的成员除了<code>cgi_buffer</code>和用于传入环境变量的<code>cgi_parameter</code>之外，<code>stdin_pipe</code>和<code>stdout_pipe</code>两个成员值得注意。</p>
<h4 id="pipe">pipe</h4>
<p><code>stdin_pipe</code>和<code>stdout_pipe</code>两个成员代表了两个pipe。pipe是Linux中的一种通信机制。一个pipe有两个fd组成，第一个代表read端，第二个代表write端。写入的数据会缓存在内核中，在读取时被取出。我们可以用pipe函数来创建一个pipe，pipe中的两个文件描述符在fork时也会被复制。所以pipe可以被作为一种进程间通信的手段。</p>
<blockquote>
<p>关于pipe的更多信息请参考<em>The Linux Programming Interface</em> Chapter 44</p>
</blockquote>
<p>我们的server主进程要和CGI进程通信，就是通过pipe做到的。</p>
<p>在CGI进程中的代码：</p>
<pre><code><span class="hljs-function">close</span>(cgi_pool-&gt;executors<span class="hljs-attr_selector">[slot]</span>-&gt;stdout_pipe<span class="hljs-attr_selector">[0]</span>);
<span class="hljs-function">close</span>(cgi_pool-&gt;executors<span class="hljs-attr_selector">[slot]</span>-&gt;stdin_pipe<span class="hljs-attr_selector">[1]</span>);
<span class="hljs-function">dup2</span>(cgi_pool-&gt;executors<span class="hljs-attr_selector">[slot]</span>-&gt;stdout_pipe<span class="hljs-attr_selector">[1]</span>, <span class="hljs-function">fileno</span>(stdout));
<span class="hljs-function">dup2</span>(cgi_pool-&gt;executors<span class="hljs-attr_selector">[slot]</span>-&gt;stdin_pipe<span class="hljs-attr_selector">[0]</span>, <span class="hljs-function">fileno</span>(stdin));
</code></pre><p>我们关闭了CGI进程中<code>stdout_pipe</code>的read端，把write端重定向到CGI进程的stdout，因为主进程要从这个pipe读取CGI进程的输出。</p>
<p>我们关闭了CGI进程中<code>stdin_pipe</code>的write端，把read端重定向到CGI进程的stdin，因为主进程要向CGI进程中写入一些信息，比如POST请求的body。</p>
<p>在主进程中，我们关闭用不到的两个fd，分别是<code>stdout_pipe</code>的write端和<code>stdin_pipe</code>的read端。</p>
<pre><code><span class="hljs-function">close</span>(cgi_pool-&gt;executors<span class="hljs-attr_selector">[slot]</span>-&gt;stdout_pipe<span class="hljs-attr_selector">[1]</span>);
<span class="hljs-function">close</span>(cgi_pool-&gt;executors<span class="hljs-attr_selector">[slot]</span>-&gt;stdin_pipe<span class="hljs-attr_selector">[0]</span>);
</code></pre><h4 id="select-cgi">select + CGI</h4>
<p>在CGI进程被创建之后，我们调用<code>add_cgi_fd_to_pool</code>函数把这个clientfd和CGI的fd一起加入到监听的连接池里面。CGI的fd是什么呢？没错，就是<code>stdin_pipe[1]</code>和<code>stdout_pipe[0]</code>，<code>stdin_pipe[1]</code>代表着CGI进程的输入，当这个fd为可写时，我们可以向CGI进程写入数据。<code>stdout_pipe[0]</code>代表着CGI进程的输出，当这个fd为可读时，我们可以从CGI进程中读取数据。加入到连接池中意味着我们可以通过select来监听CGI进程的I/O事件。所以在select的<code>handle_clients</code>里，除了客户端可写和客户端可读之外，我们需要处理CGI可写和CGI可读两种情况。</p>
<p>由此我们便可以在select中根据事件，来对客户端进行处理，转移它们的状态。一个非阻塞的事件驱动Server设计已经有了雏形。</p>
<h3 id="-liso">如何加强Liso</h3>
<p>Liso距离一个工业级的Server还有很大的差距，我们可以做的改进有：</p>
<ul>
<li>将静态文件I/O改造为基于线程池的设计。</li>
<li>使用<code>epoll</code>代替<code>select</code>。</li>
<li>支持使用DSL对服务器进行配置。</li>
<li>支持Gzip。</li>
</ul>
</div></div><footer class="footer"><address class="author">Copyright &copy;<a rel="author" href="https://github.com/zxc0328" class="author-name">ccnuzindex</a>-<a href="https://github.com/zxc0328/diary-content.git" class="source-repo">Source</a></address><p>Generated by<a href="https://github.com/joyeecheung/diary" class="site-repo">Joyee Cheung&#39;s diary generator</a></p></footer></body></html>
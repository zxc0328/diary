<!DOCTYPE html><!--[if lte IE 8]>
<html lang="en" class="lte-ie8">
<![endif]-->
<!--[if gt IE 8]><!-->
<html lang="en">
<!--<![endif]--><head><meta charset="utf-8"><title>September 23, 2017</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/diary/styles/global.css"><link rel="stylesheet" href="/diary/styles/tomorrow.css"><link rel="stylesheet" href="/diary/styles/diary.css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-63818301-1', 'auto');
ga('send', 'pageview');</script></head><body><header class="header"><div class="index"><a href="/diary/">Index</a></div><h1>September 23, 2017</h1></header><div class="content"><div class="diary"><h2 id="vue-vdom-hook-">Vue vdom hook小记</h2>
<p>Vue的vdom实现，主要包括几个部分，VNode节点的定义，element和component的创建，和patch的实现。</p>
<p>element和component都是概念上的说法，element和component都对应着一个VNode。</p>
<p>VNode可以通过patch，同步到UI。但patch的代码主要只是写了新老VNode的增删，对于不同VNode的具体修改，则没有直接实现。</p>
<p>这就是Vue vdom实现的精妙之处，对VNode的patch操作中，会有几个时间节点，分别是：创建节点（create）、激活节点（activate）、更新节点（update）、移除节点（remove）、销毁节点（destroy）。</p>
<p>简而言之，Vue的生命周期、指令、事件、样式等等的更新，都是通过在这些时间节点注册hook函数实现的。</p>
<p>在Vue的vdom中，一组hook叫做一个module。一个module包括以上说的生命周期中的一个或者多个。比如指令模块，就有create、update和destroy三个hook。</p>
<p>vdom的patch函数是在运行时生成的，根据不同的平台，我们可以传入不同的modules。这些modules，也是就是包含了hook的对象，会在生成patch函数的模块中，被统一按生命周期归类，在对应的时间节点，取出里面的hook，依次调用。</p>
<p>比如：</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invokeCreateHooks</span> (<span class="hljs-title">vnode</span>, <span class="hljs-title">insertedVnodeQueue</span>) {</span>
    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; cbs.<span class="hljs-built_in">create</span>.<span class="hljs-built_in">length</span>; ++i) {
      cbs.<span class="hljs-built_in">create</span>[i](emptyNode, vnode)
    }
    i = vnode.data.hook<span class="hljs-comment"> // Reuse variable</span>
    <span class="hljs-keyword">if</span> (isDef(i)) {
      <span class="hljs-keyword">if</span> (isDef(i.<span class="hljs-built_in">create</span>)) i.<span class="hljs-built_in">create</span>(emptyNode, vnode)
      <span class="hljs-keyword">if</span> (isDef(i.insert)) insertedVnodeQueue.push(vnode)
    }
  }
</code></pre><p>比较有意思的几点：</p>
<p>Vue的组件会有一个对应的placeholder VNode。这个VNode上会有一些hook，这些hook是和组件的一些逻辑有关的。比如在VNode初始化的时候实例化组件，在VNode被销毁的时候销毁组件实例等等。</p>
<p>其中有一个hook叫prepatch，这个hook在vdom的patch流程中没有对应的时间节点，这个hook其实是在两个vdom真正的diff之前被调用的：</p>
<pre><code><span class="hljs-keyword">if</span> <span class="hljs-comment">(isDef(data)</span> &amp;&amp; isDef<span class="hljs-comment">(i = data.hook)</span> &amp;&amp; isDef<span class="hljs-comment">(i = i.prepatch)</span>) {
      i<span class="hljs-comment">(oldVnode, vnode)</span>
    }
</code></pre><p>然后就是inserted这个hook。之前说了，Vue的组件对应的VNode是一个placeholder，并不会真正插入文档，真正插入文档的是组件的root element。所以在patch流程中，会对有parent的placeholder element做特殊的处理。在插入操作时：</p>
<pre><code><span class="hljs-function">function <span class="hljs-title">invokeInsertHook</span> <span class="hljs-params">(vnode, <span class="hljs-built_in">queue</span>, initial)</span> </span>{
    <span class="hljs-comment">// delay insert hooks for component root nodes, invoke them after the</span>
    <span class="hljs-comment">// element is really inserted</span>
    <span class="hljs-keyword">if</span> (isTrue(initial) &amp;&amp; isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = <span class="hljs-built_in">queue</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">queue</span>.length; ++i) {
        <span class="hljs-built_in">queue</span>[i].data.hook.insert(<span class="hljs-built_in">queue</span>[i])
      }
    }
  }
</code></pre><p>延迟inserted到子元素被插入时才调用。</p>
<pre><code><span class="hljs-keyword">if</span> (isDef(vnode.<span class="hljs-keyword">parent</span>)) {
          <span class="hljs-comment">// component root element replaced.</span>
          <span class="hljs-comment">// update parent placeholder node element, recursively</span>
          <span class="hljs-keyword">let</span> ancestor = vnode.<span class="hljs-keyword">parent</span>
          <span class="hljs-keyword">const</span> patchable = isPatchable(vnode)
          <span class="hljs-keyword">while</span> (ancestor) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor)
            }
            ancestor.elm = vnode.elm
            <span class="hljs-keyword">if</span> (patchable) {
              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; cbs.create.length; ++i) {
                cbs.create[i](emptyNode, ancestor)
              }
              <span class="hljs-comment">// #6513</span>
              <span class="hljs-comment">// invoke insert hooks that may have been merged by create hooks.</span>
              <span class="hljs-comment">// e.g. for directives that uses the "inserted" hook.</span>
              <span class="hljs-keyword">const</span> insert = ancestor.data.hook.insert
              <span class="hljs-keyword">if</span> (insert.merged) {
                <span class="hljs-comment">// start at index 1 to avoid re-invoking component mounted hook</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; insert.fns.length; i++) {
                  insert.fns[i]()
                }
              }
            }
            ancestor = ancestor.<span class="hljs-keyword">parent</span>
          }
        }
</code></pre><p>在root element被调用时，对组件进行更新，重新调用destroy和create函数。</p>
<p>现在对hook的了解比之前多了一些，主要是对于placeholder元素的处理上，有了更多的了解。组件对应一个placeholder元素是一种通常的做法，React应该也是这样的。</p>
</div></div><footer class="footer"><address class="author">Copyright &copy;<a rel="author" href="https://github.com/zxc0328" class="author-name">ccnuzindex</a>-<a href="https://github.com/zxc0328/diary-content.git" class="source-repo">Source</a></address><p>Generated by<a href="https://github.com/joyeecheung/diary" class="site-repo">Joyee Cheung&#39;s diary generator</a></p></footer></body></html>
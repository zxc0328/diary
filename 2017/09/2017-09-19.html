<!DOCTYPE html><!--[if lte IE 8]>
<html lang="en" class="lte-ie8">
<![endif]-->
<!--[if gt IE 8]><!-->
<html lang="en">
<!--<![endif]--><head><meta charset="utf-8"><title>September 19, 2017</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/diary/styles/global.css"><link rel="stylesheet" href="/diary/styles/tomorrow.css"><link rel="stylesheet" href="/diary/styles/diary.css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-63818301-1', 'auto');
ga('send', 'pageview');</script></head><body><header class="header"><div class="index"><a href="/diary/">Index</a></div><h1>September 19, 2017</h1></header><div class="content"><div class="diary"><h2 id="mui-table-slot-">MUI Table组件：slot内容的跨级传递</h2>
<p>在开发MUI的Table组件时，我们遇到了一个问题。用户在顶层组件中嵌套的内容，需要被保存到组件的数据中，并且在表格内部渲染出来。</p>
<p>通常，Vue内嵌内容是使用slot进行渲染的。在父组件的模板中，在子组件的标签中嵌入模板，然后在子组件的内部，使用<code>&lt;slot/&gt;</code>标签进行渲染。但现在我们的需求是非父子组件的slot渲染，这就要求我们换一种思路去保存和调用slot。</p>
<p>要理解以下的内容，<strong>请确保你阅读了<a href="https://vuejs.org/v2/guide/render-function.html">Render Functions &amp; JSX</a>，理解了Vue的VNode、render function、模板等概念以及这些概念之间的关系</strong>。</p>
<!-- more -->
<h3 id="slot-">slot方案</h3>
<p>首先要明确一个点，所谓的slot就指的是一个组件在声明时候的内嵌内容。Vue的模板都会被编译成VNode节点树，slot指的是一个VNode的<code>children</code>属性这个数组里包含的VNode节点集合，这些内容由组件声明时的内嵌内容编译而来。</p>
<p>我们可以通过<code>this.$slots.default</code>拿到默认的子VNode列表。如果内嵌内容上没有声明<code>name</code>属性，那这些内容都归属于<code>default</code>这个属性。</p>
<p>所以Slot其实就是一个VNode数组，我们可以把这个数组作为<code>prop</code>传入子节点进行渲染。</p>
<blockquote>
<p><code>{{ vnode }}</code>这种语法会把vnode作为一个对象去序列化，这不是我们所期望的。所以我们需要用<code>v-bind</code>去传递VNodes的引用。</p>
</blockquote>
<p>想要渲染slot，可以使用<code>render function</code>。之前讲过，slot其实就是VNode的children，所以我们在<code>render function</code>中<code>createElement</code>的时候把slot的引用作为children传入就可以了。</p>
<pre><code>render(createElement) {
        <span class="hljs-keyword">return</span> createElement(<span class="hljs-string">'div'</span>, <span class="hljs-keyword">this</span>.content)
    }
</code></pre><blockquote>
<p>在组件初始化时给this.$slots赋值，然后在模板中使用slot渲染或许也是一种办法，但不一定行的通，也比较hacky。</p>
</blockquote>
<p>但我们发现这样不能达到目的。VNode是Vue中对一个DOM节点的内部表示，VNode是有状态的，一个VNode同时只能渲染出一个DOM节点实例。也就是说一个VNode在渲染之后不能再次渲染，除非先把这个VNode从文档中移除，然后才可以再次渲染。</p>
<p>所以，因为我们的表格中的VNodes是会被每一个row复用的，现在这种用法只能渲染第一行的slot内容。</p>
<p>解决方案就是，用一个<code>deepClone</code>函数clone VNode，在每次渲染时初始化新的VNodes实例。</p>
<pre><code>render(createElement) {
        <span class="hljs-keyword">return</span> createElement(<span class="hljs-string">'div'</span>, deepClone(<span class="hljs-keyword">this</span>.content, createElement))
    }
</code></pre><h3 id="scopedslots-">scopedSlots方案</h3>
<p>这样似乎就可以解决问题了，但我们发现Table的自定义内容常常是一个按钮这样的可以交互的组件，会有事件绑定，如果我们要在子组件中给slot动态传入属性，这是办不到的。</p>
<p>所以slot就不能满足我们的需求了，更好的解决方案就是scopedSlots。</p>
<p>要了解什么是scopedSlots，我们首先将scopedSlots的模板：</p>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">scoped</span>=<span class="hljs-value">"prop"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre><p>进行编译，结果是：</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">anonymous</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">with</span>(<span class="hljs-keyword">this</span>){<span class="hljs-keyword">return</span> _c(<span class="hljs-string">'div'</span>,{scopedSlots:_u([{key:<span class="hljs-string">"default"</span>,fn:<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(prop)</span></span>{<span class="hljs-keyword">return</span> [_c(<span class="hljs-string">'div'</span>)]}}])})}
}
</code></pre><p>这种形式是我们之前没有遇到过的，scopedSlots被编译后，生成了一个函数，而且scopedSlot是被存放在VNode的<code>data</code>属性中，而不是在<code>children</code>中。</p>
<p>仔细观察这个函数，这个函数接收一个参数，然后返回一个VNode，这个VNode的属性是从这个参数中获取的。那scopedSlots的原理就很清楚了，<strong>scopedSlots就是一个lazy evaluation的函数，在需要渲染的时候，接收scope对象，然后渲染。这样就可以达到一个类似动态作用域的效果</strong>。</p>
<p>既然scopedSlots是一个函数，我们在render function里面只要调用这个函数，并且传入对应的scope对象作为参数就可以了：</p>
<pre><code>render(createElement) {
        <span class="hljs-keyword">const</span> prop = {
            index: <span class="hljs-keyword">this</span>.id
        }
        <span class="hljs-keyword">return</span> createElement(<span class="hljs-string">'div'</span>, [
            <span class="hljs-keyword">this</span>.content.call(<span class="hljs-keyword">this</span>, prop)
        ])
    }
</code></pre><p>这种形式顺便解决了之前slot无法重复利用VNode的问题，<strong>因为scopedSlots函数每次返回的都是一个新的VNode节点</strong>。</p>
</div></div><footer class="footer"><address class="author">Copyright &copy;<a rel="author" href="https://github.com/zxc0328" class="author-name">ccnuzindex</a>-<a href="https://github.com/zxc0328/diary-content.git" class="source-repo">Source</a></address><p>Generated by<a href="https://github.com/joyeecheung/diary" class="site-repo">Joyee Cheung&#39;s diary generator</a></p></footer></body></html>